import numpy as np
import pandas as pd

def predict_positions_between_lost_and_found(lost_row, found_row):
    """
    Predict intermediate positions between a lost row and a found row,
    including computation of `distance_km` for each predicted step.

    Parameters:
    lost_row (pd.Series): Row with initial "lost" position and SOG/COG.
    found_row (pd.Series): Row with final "found" position and SOG/COG.

    Returns:
    pd.DataFrame: Predicted positions up to the found row.
    """
    KNOTS_TO_METERS_PER_SEC = 0.514444

    # Extract initial and final positions
    x_start, y_start, z_start = lost_row["x"], lost_row["y"], lost_row["z"]
    x_end, y_end, z_end = found_row["x"], found_row["y"], found_row["z"]
    
    # Extract initial and final speeds and angles
    sog_start, cog_start = lost_row["SOG"], lost_row["COG"]
    sog_end, cog_end = found_row["SOG"], found_row["COG"]
    
    # Calculate total duration
    duration_total = found_row["duration_seconds"]
    
    # Number of prediction steps
    num_steps = int(duration_total)  # Assume one step per second
    if num_steps <= 0:
        raise ValueError("Duration between lost and found rows must be positive.")
    
    # Initialize the prediction DataFrame
    predictions = []
    cumulative_distance = 0  # Initialize cumulative distance

    # Start position for cumulative distance calculation
    x_previous, y_previous, z_previous = x_start, y_start, z_start

    for step in range(1, num_steps + 1):
        # Interpolate speed (SOG) and course (COG)
        sog_interp = sog_start + (sog_end - sog_start) * step / num_steps
        cog_interp = cog_start + (cog_end - cog_start) * step / num_steps

        # Convert SOG to meters per second
        speed = sog_interp * KNOTS_TO_METERS_PER_SEC

        # Convert COG to radians
        cog_radians = np.radians(cog_interp)

        # Compute velocity components
        vx = speed * np.cos(cog_radians)
        vy = speed * np.sin(cog_radians)

        # Compute position increment
        time_step = duration_total / num_steps
        dx = vx * time_step
        dy = vy * time_step

        # Calculate intermediate positions
        x_current = x_start + dx * step
        y_current = y_start + dy * step
        z_current = z_start + (z_end - z_start) * step / num_steps

        # Compute step distance and update cumulative distance
        step_distance = np.sqrt((x_current - x_previous)**2 + (y_current - y_previous)**2 + (z_current - z_previous)**2)
        cumulative_distance += step_distance
        distance_km = cumulative_distance / 1000  # Convert to kilometers

        # Update previous position
        x_previous, y_previous, z_previous = x_current, y_current, z_current

        # Append the prediction
        predictions.append({
            "step": step,
            "SOG": sog_interp,
            "COG": cog_interp,
            "x": x_current,
            "y": y_current,
            "z": z_current,
            "time_elapsed": step * time_step,
            "distance_km": distance_km
        })

    # Convert predictions to a DataFrame
    predictions_df = pd.DataFrame(predictions)
    return predictions_df

# Example usage:
lost_row = pd.Series({
    "SOG": 0.1,
    "COG": 220.5,
    "x": 978.775466,
    "y": -5636.091653,
    "z": 2804.658708,
    "distance_km": 0.563219,
    "duration_seconds": 62.0
})

found_row = pd.Series({
    "SOG": 10.6,
    "COG": 186.0,
    "x": 977.761677,
    "y": -5441.347041,
    "z": 3166.285755,
    "distance_km": 0.563219,
    "duration_seconds": 62.0
})

# Predict positions between lost and found
predicted_positions = predict_positions_between_lost_and_found(lost_row, found_row)

# Display the predicted positions
print(predicted_positions)
