import numpy as np
import pandas as pd

def predict_positions_between_lost_and_found(lost_row, found_row):
    """
    Predict intermediate positions between a lost row and a found row,
    including computation of `distance_km` for each predicted step.

    Parameters:
    lost_row (pd.Series): Row with initial "lost" position and SOG/COG.
    found_row (pd.Series): Row with final "found" position and SOG/COG.

    Returns:
    pd.DataFrame: Predicted positions up to the found row.
    """
    KNOTS_TO_METERS_PER_SEC = 0.514444

    # Extract initial and final positions
    x_start, y_start, z_start = lost_row["x"], lost_row["y"], lost_row["z"]
    x_end, y_end, z_end = found_row["x"], found_row["y"], found_row["z"]
    
    # Extract initial and final speeds and angles
    sog_start, cog_start = lost_row["SOG"], lost_row["COG"]
    sog_end, cog_end = found_row["SOG"], found_row["COG"]
    
    # Calculate total duration
    duration_total = found_row["duration_seconds"]
    
    # Number of prediction steps
    num_steps = int(duration_total)  # Assume one step per second
    if num_steps <= 0:
        raise ValueError("Duration between lost and found rows must be positive.")
    
    # Initialize the prediction DataFrame
    predictions = []
    cumulative_distance = 0  # Initialize cumulative distance

    # Start position for cumulative distance calculation
    x_previous, y_previous, z_previous = x_start, y_start, z_start

    for step in range(1, num_steps + 1):
        # Interpolate speed (SOG) and course (COG)
        sog_interp = sog_start + (sog_end - sog_start) * step / num_steps
        cog_interp = cog_start + (cog_end - cog_start) * step / num_steps

        # Convert SOG to meters per second
        speed = sog_interp * KNOTS_TO_METERS_PER_SEC

        # Convert COG to radians
        cog_radians = np.radians(cog_interp)

        # Compute velocity components
        vx = speed * np.cos(cog_radians)
        vy = speed * np.sin(cog_radians)

        # Compute position increment
        time_step = duration_total / num_steps
        dx = vx * time_step
        dy = vy * time_step

        # Calculate intermediate positions
        x_current = x_start + dx * step
        y_current = y_start + dy * step
        z_current = z_start + (z_end - z_start) * step / num_steps

        # Compute step distance and update cumulative distance
        step_distance = np.sqrt((x_current - x_previous)**2 + (y_current - y_previous)**2 + (z_current - z_previous)**2)
        cumulative_distance += step_distance
        distance_km = cumulative_distance / 1000  # Convert to kilometers

        # Update previous position
        x_previous, y_previous, z_previous = x_current, y_current, z_current

        # Append the prediction
        predictions.append({
            "step": step,
            "SOG": sog_interp,
            "COG": cog_interp,
            "x": x_current,
            "y": y_current,
            "z": z_current,
            "time_elapsed": step * time_step,
            "distance_km": distance_km
        })

    # Convert predictions to a DataFrame
    predictions_df = pd.DataFrame(predictions)
    return predictions_df

# Example usage:
lost_row = pd.Series({
    "SOG": 0.1,
    "COG": 220.5,
    "x": 978.775466,
    "y": -5636.091653,
    "z": 2804.658708,
    "distance_km": 0.563219,
    "duration_seconds": 62.0
})

found_row = pd.Series({
    "SOG": 10.6,
    "COG": 186.0,
    "x": 977.761677,
    "y": -5441.347041,
    "z": 3166.285755,
    "distance_km": 0.563219,
    "duration_seconds": 62.0
})

# Predict positions between lost and found
predicted_positions = predict_positions_between_lost_and_found(lost_row, found_row)

# Display the predicted positions
print(predicted_positions)


========================================================================
import numpy as np
import pandas as pd

def haversine_distance(lat1, lon1, lat2, lon2):
    """
    Calculate the Haversine distance between two points on the Earth's surface.
    
    Parameters:
    lat1, lon1: Latitude and Longitude of the first point (in degrees)
    lat2, lon2: Latitude and Longitude of the second point (in degrees)
    
    Returns:
    Distance in kilometers
    """
    R = 6371  # Radius of the Earth in kilometers
    # Convert degrees to radians
    lat1, lon1, lat2, lon2 = map(np.radians, [lat1, lon1, lat2, lon2])
    
    # Haversine formula
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat / 2) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2) ** 2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))
    
    # Distance in kilometers
    distance = R * c
    return distance

def predict_positions_between_lost_and_found(lost_row, found_row):
    """
    Predict intermediate positions between a lost row and a found row.

    Parameters:
    lost_row (pd.Series): Row with initial "lost" position and SOG/COG.
    found_row (pd.Series): Row with final "found" position and SOG/COG.

    Returns:
    pd.DataFrame: Predicted positions up to the found row.
    """
    KNOTS_TO_METERS_PER_SEC = 0.514444

    # Extract initial and final positions (latitude, longitude, and altitude)
    lat_start, lon_start, z_start = lost_row["latitude"], lost_row["longitude"], lost_row["z"]
    lat_end, lon_end, z_end = found_row["latitude"], found_row["longitude"], found_row["z"]
    
    # Extract initial and final speeds and angles
    sog_start, cog_start = lost_row["SOG"], lost_row["COG"]
    sog_end, cog_end = found_row["SOG"], found_row["COG"]
    
    # Calculate total distance and duration
    duration_total = found_row["duration_seconds"]
    
    # Number of prediction steps
    num_steps = int(duration_total)  # Assume one step per second
    if num_steps <= 0:
        raise ValueError("Duration between lost and found rows must be positive.")
    
    # Initialize the prediction DataFrame
    predictions = []

    for step in range(1, num_steps + 1):
        # Interpolate speed (SOG) and course (COG)
        sog_interp = sog_start + (sog_end - sog_start) * step / num_steps
        cog_interp = cog_start + (cog_end - cog_start) * step / num_steps

        # Convert SOG to meters per second
        speed = sog_interp * KNOTS_TO_METERS_PER_SEC

        # Convert COG to radians
        cog_radians = np.radians(cog_interp)

        # Compute velocity components
        vx = speed * np.cos(cog_radians)
        vy = speed * np.sin(cog_radians)

        # Compute position increment
        time_step = duration_total / num_steps
        dx = vx * time_step
        dy = vy * time_step

        # Calculate intermediate positions
        lat_current = lat_start + (lat_end - lat_start) * step / num_steps
        lon_current = lon_start + (lon_end - lon_start) * step / num_steps
        z_current = z_start + (z_end - z_start) * step / num_steps

        # Calculate the distance from the start using the Haversine formula
        distance_km = haversine_distance(lat_start, lon_start, lat_current, lon_current)

        # Append the prediction
        predictions.append({
            "step": step,
            "SOG": sog_interp,
            "COG": cog_interp,
            "latitude": lat_current,
            "longitude": lon_current,
            "z": z_current,
            "time_elapsed": step * time_step,
            "distance_km": distance_km
        })

    # Convert predictions to a DataFrame
    predictions_df = pd.DataFrame(predictions)
    return predictions_df

# Example usage:
lost_row = pd.Series({
    "SOG": 0.1,
    "COG": 220.5,
    "latitude": 53.349805,
    "longitude": -6.26031,
    "z": 2804.658708,
    "duration_seconds": 62.0
})

found_row = pd.Series({
    "SOG": 10.6,
    "COG": 186.0,
    "latitude": 53.348150,
    "longitude": -6.245013,
    "z": 3166.285755,
    "duration_seconds": 62.0
})

# Predict positions between lost and found
predicted_positions = predict_positions_between_lost_and_found(lost_row, found_row)

# Display the predicted positions
print(predicted_positions)

